const Component = require('./components/Component')
const h = require('snabbdom/h').default

// General todos:
// - JSON representation of the module, for saving and loading

// The whole module iterates with a stop condition
// step the whole module forward, backwards with arrow keys
// Every value cell has a starting value and a step command (map), and a stop condition

/*
 * Challenge question:
 *
 * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
 * Find the sum of all the multiples of 3 or 5 below 1000.
 *
 * a; start=3; stop=a 1000 gte; step=a 3 add
 * b; start=5; end=b 1000 gte; step=b 5 add
 * c; start=15; end=c 1000 gte; step=c 15 add
 * sum; a b add
 * diff; sum c sub
 *
 * We will need some kind of iterator/range cell that:
 * - starts at 3 and goes up by 3 until 100
 * - another iter starts at 5 and goes up by 5 until 100
 * - a reducer listens to any value from the above two iters and adds them up
 */

/* Challenge question 2:
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 *
 *  x; start=0; step=y
 *  limit; start=4000000
 *  y; start=1; step=x y add; stop=y limit gte
 *  evens; start=0; step=y (is_even) filter
 *  sum-evens; start=0; accum=this evens add
*/

/* Question 3:
 * The prime factors of 13195 are 5, 7, 13 and 29.
 * What is the largest prime factor of the number 600851475143 ?
 *
 * - Start with i=2, loop while less than N
 * - check if i divides N
 *   - if it does, then N = N/i, and add i to the set of factors
 *   - otherwise, increment i
 * - return the set of factors
 */

function Module () {
  return Component({
    newCellName: '',
    cells: {},
    isValidCellName (name) {
      return name && name.length && !(name in this.cells)
    },
    createCell (creator, args) {
      const name = this.newCellName.trim()
      if (!this.isValidCellName(name)) {
        console.error('Invalid name')
        return
      }
      this.cells[name] = Cell(this, name)
      this._render()
    },
    view () {
      return h('div', [
        h('div', [
          h('label', 'Module name'),
          h('input', {
            props: {
              type: 'text'
            }
          })
        ]),
        // CPU stepper buttons
        h('div', [
          h('button', {
            on: {
              click: () => {
                for (let name in this.cells) {
                  const cell = this.cells[name]
                  cell.reset()
                }
              }
            }
          }, [ 'Reset' ]),
          h('button', {
            on: {
              click: () => {
                for (let name in this.cells) {
                  const cell = this.cells[name]
                  cell.tick()
                }
              }
            }
          }, [ 'Step forward' ])
        ]),
        // New cell controls
        h('div', [
          h('input', {
            props: {
              placeholder: 'New name',
              value: this.newCellName,
              type: 'text'
            },
            on: {
              input: ev => {
                this.newCellName = ev.currentTarget.value
              }
            }
          }),
          h('button', {
            on: { click: () => this.createCell() }
          }, 'Add Cell')
        ]),
        h('div', Object.entries(this.cells).map(([name, cell]) => {
          return h('div', [ cell.view() ])
        }))
      ])
    }
  })
}

function Cell (module, name) {
  return Component({
    name,
    module,
    val: null,
    start: null,
    ended: false,
    pending: true, // no ticks yet
    tick: function () {
      if (this.ended) return
      this.pending = false
      if (this.end) {
        if (this.end()) {
          this.ended = true
          this._render()
          return
        }
      }
      if (this.step) {
        this.val = this.step()
        this._render()
      }
    },
    reset: function () {
      this.val = this.start
      this.ended = false
      this.pending = true
      this._render()
    },
    view: function () {
      return h('div', [
        h('p', ['Cell: ', this.name]),
        h('div', [
          h('input', {
            props: {
              type: 'text',
              placeholder: 'Starting value'
            },
            on: {
              input: ev => {
                const val = ev.currentTarget.value.trim()
                this.start = Number(val)
                if (this.pending) {
                  this.val = this.start
                  this._render()
                }
              }
            }
          })
        ]),
        h('p', ['Value: ', this.val])
      ])
    }
  })
}

/*
function Value (module) {
  return Component({
    id: id++,
    module,
    val: 0,
    downstream: {},
    iterator () {
      return fn => { fn(this.val) }
    },
    evaluate () {
      for (let id in this.downstream) {
        const cell = this.downstream[id]
        cell.evaluate()
        cell._render()
      }
    },
    addDownstream (ref) {
      this.downstream[ref.id] = ref
    },
    view () {
      return h('div', [
        'value: ',
        h('input', {
          props: {
            value: this.val,
            type: 'number'
          },
          on: {
            input: (ev) => {
              this.val = Number(ev.currentTarget.value)
              this.evaluate()
            }
          }
        })
      ])
    }
  })
}
*/

/*
function Looper (module) {
  return Component({
  })
}

let id = 0

// TODO remove relationship reference on change

// Relationship
function Rel (module) {
  return Component({
    id: id++,
    module,
    val: null,
    refs: [],
    downstream: [],
    pipeline: [],
    evaluate () {
      this.val = this.refs.map(ref => this.module.cells[ref].val)
      console.log('val', this.val)
      this.pipeline.forEach(fn => {
        this.val = fn(this.val)
      })
      for (let id in this.downstream) {
        const cell = this.downstream[id]
        cell.evaluate()
        cell._render()
      }
    },
    addDownstream (cell) {
      this.downstream[cell.id] = cell
    },
    view () {
      return h('div', [
        h('input', {
          props: {
            type: 'text',
            placeholder: 'References'
          },
          on: {
            change: ev => {
              // TODO remove a ref, when necessary
              const refs = ev.currentTarget.value.trim().split(' ')
              refs.forEach(ref => {
                if (!(ref in this.module.cells)) {
                  throw new Error('Invalid reference')
                }
                this.module.cells[ref].addDownstream(this)
              })
              this.refs = refs
              this.evaluate()
              this._render()
            }
          }
        }),
        h('input', {
          props: {
            type: 'text',
            placeholder: 'Commands'
          },
          on: {
            change: ev => {
              const cmds = ev.currentTarget.value.trim().split(' ')
              if (!cmds || !cmds.length) return
              this.pipeline = createPipeline(cmds)
              this.evaluate()
              this._render()
            }
          }
        }),
        'value: ',
        String(this.val)
      ])
    }
  })
}

function createPipeline (cmds) {
  return cmds.filter(cmd => cmd in builtins).map(cmd => {
    return builtins[cmd]
  })
}

const builtins = {
  add: (ns) => ns.reduce((sum, n) => sum + n, 0),
  sub: (ns) => ns.reduce((diff, n) => diff - n)
}

function Range (module) {
  return Component({
    id: id++,
    module,
    start: 1,
    stop: 100,
    step: 1,
    val: 1,
    downstream: {},
    iterator () {
      return fn => {
        if (!this.start || !this.stop || !this.step) return
        for (let i = this.start; i <= this.stop; i += this.step) {
          fn(i)
        }
      }
    },
    addDownstream (cell) {
      this.downstream[cell.id] = cell
    },
    evaluate () {
      for (let id in this.downstream) {
        const cell = this.downstream[id]
        cell.evaluate()
        cell._render()
      }
    },
    view () {
      return h('div', [
        h('input', {
          props: {
            placeholder: 'Start value',
            value: this.start,
            type: 'number'
          },
          on: {
            input: ev => {
              const val = Number(ev.currentTarget.value)
              this.start = val
              this.evaluate()
              this._render()
            }
          }
        }),
        h('input', {
          props: {
            placeholder: 'Step amount',
            value: this.step,
            type: 'number'
          },
          on: {
            input: ev => {
              const val = Number(ev.currentTarget.value)
              this.step = val
              this.evaluate()
              this._render()
            }
          }
        }),
        h('input', {
          props: {
            placeholder: 'Stop value',
            value: this.stop,
            type: 'number'
          },
          on: {
            input: ev => {
              const val = Number(ev.currentTarget.value)
              this.stop = val
              this.evaluate()
              this._render()
            }
          }
        })
        // TODO buttons to pause, reset, and step
      ])
    }
  })
}

// Iterative reducer
function Accum (module) {
  return Component({
    id: id++,
    module,
    start: 0,
    pipeline: [],
    val: null,
    downstream: {},
    addDownstream (cell) {
      this.downstream[cell.id] = cell
    },
    evaluate () {
      const refIterator = this.module.cells[this.ref].iterator()
      const applyPipeline = (accum, step) => {
        if (!this.pipeline.length) return this.start
        // TODO apply all in the pipeline
        return this.pipeline[0]([this.val, step])
      }
      this.val = this.start
      refIterator(val => {
        this.val = applyPipeline(this.val, val)
      })
      for (let id in this.downstream) {
        const cell = this.downstream[id]
        cell.evaluate()
        cell._render()
      }
    },
    view () {
      return h('div', [
        h('input', {
          props: {
            value: this.ref,
            type: 'text',
            placeholder: 'Reference'
          },
          on: {
            change: ev => {
              const val = ev.currentTarget.value.trim()
              if (!(val in this.module.cells)) {
                console.error('Invalid reference ' + val)
              }
              this.module.cells[val].addDownstream(this)
              this.ref = val
              this.evaluate()
              this._render()
            }
          }
        }),
        h('input', {
          props: {
            type: 'number',
            value: this.start,
            placeholder: 'Start val'
          },
          on: {
            input: ev => {
              const val = Number(ev.currentTarget.value.trim())
              this.start = val
            }
          }
        }),
        h('input', {
          props: {
            type: 'text',
            value: this.command,
            placeholder: 'Command'
          },
          on: {
            change: ev => {
              const cmds = ev.currentTarget.value.trim().split(' ')
              if (!cmds || !cmds.length) return
              this.pipeline = createPipeline(cmds)
              this.evaluate()
              this._render()
            }
          }
        }),
        'value: ',
        this.val
      ])
    }
  })
}
*/

document._module = Module()
document.body.appendChild(document._module._render().elm)
